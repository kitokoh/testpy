import uuid
from typing import List, Optional, Dict, Any
from sqlalchemy.orm import Session, joinedload, selectinload
from sqlalchemy import func, select, update, delete, and_

# Assuming models are in api.models
# Adjust import path if models are located elsewhere (e.g., directly in db.models if that's the project structure)
from api.models import ProformaInvoice, ProformaInvoiceItem, ProformaInvoiceStatusEnum, Client, Project, Company, Product, ClientDocument

# Placeholder for get_db_session - this should come from your actual db setup (e.g., db.py or db_context_extensions.py)
# For this subtask, we'll assume it's available globally or passed in.
# from db import get_db_session # Example if it's in db.py

def get_db_session() -> Session:
    # This is a placeholder. In a real FastAPI app, Session is usually injected
    # via Depends or a context manager.
    # If your project has a global session factory or similar, use that.
    # For now, this will raise an error if not replaced.
    raise NotImplementedError("get_db_session() needs to be implemented or provided to CRUD functions.")

# --- ProformaInvoice CRUD ---

def create_proforma_invoice(db: Session, proforma_data: Dict[str, Any], items_data: List[Dict[str, Any]]) -> ProformaInvoice:
    """
    Creates a new Proforma Invoice and its associated items.
    'proforma_data' should contain all necessary fields for ProformaInvoice.
    'items_data' should be a list of dictionaries, each for a ProformaInvoiceItem.
    """
    # Convert status string to Enum if necessary
    if 'status' in proforma_data and isinstance(proforma_data['status'], str):
        try:
            proforma_data['status'] = ProformaInvoiceStatusEnum[proforma_data['status'].upper()]
        except KeyError:
            # Handle invalid status string, e.g., default or raise error
            proforma_data['status'] = ProformaInvoiceStatusEnum.DRAFT # Default to DRAFT

    # Ensure proforma_invoice_number is present
    if not proforma_data.get('proforma_invoice_number'):
        # Generate a default one if not provided, or raise error
        # This logic might be more complex (e.g., sequential numbering)
        proforma_data['proforma_invoice_number'] = f"PI-{uuid.uuid4().hex[:8].upper()}"


    db_proforma_invoice = ProformaInvoice(**proforma_data)
    db.add(db_proforma_invoice)
    # Flush to get the proforma_invoice.id if it's generated by DB or needed by items before commit
    # db.flush() # Not strictly necessary if IDs are UUIDs set by app

    created_items = []
    for item_data in items_data:
        # Ensure proforma_invoice_id is not part of item_data initially, will be set by relationship
        item_data.pop('proforma_invoice_id', None) # Remove if present, will be set by relationship or manually
        db_item = ProformaInvoiceItem(**item_data)
        created_items.append(db_item)
        # db.add(db_item) # Adding through relationship is often preferred

    db_proforma_invoice.items = created_items # Assign items to relationship; SQLAlchemy handles linking via proforma_invoice_id

    try:
        db.commit()
        db.refresh(db_proforma_invoice) # To get any server-side defaults or updated state
        # Refresh items as well if needed (especially if they have defaults or generated values)
        for item in db_proforma_invoice.items: # Iterate over items associated through relationship
            db.refresh(item)
        return db_proforma_invoice
    except Exception as e:
        db.rollback()
        # Log error: print(f"Error creating proforma invoice: {e}")
        raise e


def get_proforma_invoice_by_id(db: Session, proforma_invoice_id: str) -> Optional[ProformaInvoice]:
    """Fetches a Proforma Invoice by its ID, including related items and their products."""
    return db.query(ProformaInvoice).options(
        selectinload(ProformaInvoice.items).selectinload(ProformaInvoiceItem.product), # Load items and their products
        selectinload(ProformaInvoice.client),
        selectinload(ProformaInvoice.project),
        selectinload(ProformaInvoice.company), # Seller
        selectinload(ProformaInvoice.linked_document),
        selectinload(ProformaInvoice.generated_invoice_document)
    ).filter(ProformaInvoice.id == proforma_invoice_id).first()

def get_proforma_invoice_by_number(db: Session, proforma_invoice_number: str) -> Optional[ProformaInvoice]:
    """Fetches a Proforma Invoice by its proforma_invoice_number, including related items."""
    return db.query(ProformaInvoice).options(
        selectinload(ProformaInvoice.items) # Adjust related data loading as needed
    ).filter(ProformaInvoice.proforma_invoice_number == proforma_invoice_number).first()


def list_proforma_invoices(
    db: Session,
    client_id: Optional[str] = None,
    project_id: Optional[str] = None,
    company_id: Optional[str] = None, # Seller company
    status: Optional[ProformaInvoiceStatusEnum] = None,
    status_str: Optional[str] = None, # Allow string for status
    skip: int = 0,
    limit: int = 100
) -> List[ProformaInvoice]:
    
    query = db.query(ProformaInvoice).order_by(ProformaInvoice.created_date.desc())

    if client_id:
        query = query.filter(ProformaInvoice.client_id == client_id)
    if project_id:
        query = query.filter(ProformaInvoice.project_id == project_id)
    if company_id:
        query = query.filter(ProformaInvoice.company_id == company_id)

    final_status_to_filter = None
    if status:
        final_status_to_filter = status
    elif status_str:
        try:
            final_status_to_filter = ProformaInvoiceStatusEnum[status_str.upper()]
        except KeyError:
            # Invalid status string, either ignore, raise error, or return empty list
            # For this example, we'll ignore it if it's invalid.
            pass

    if final_status_to_filter:
        query = query.filter(ProformaInvoice.status == final_status_to_filter)

    return query.offset(skip).limit(limit).all()

def update_proforma_invoice(db: Session, proforma_invoice_id: str, update_data: Dict[str, Any]) -> Optional[ProformaInvoice]:
    """
    Updates a Proforma Invoice.
    'update_data' is a dictionary with fields to update.
    Items are not updated through this function; use specific item update functions or manage items separately.
    """
    db_proforma_invoice = get_proforma_invoice_by_id(db, proforma_invoice_id) # Uses eager loading options
    if not db_proforma_invoice:
        return None

    if 'status' in update_data and isinstance(update_data['status'], str):
        try:
            update_data['status'] = ProformaInvoiceStatusEnum[update_data['status'].upper()]
        except KeyError:
            # Handle invalid status string, e.g., remove from update_data or raise error
            # For this example, we remove it to prevent setting an invalid status
            del update_data['status']


    for key, value in update_data.items():
        # Ensure not to try setting relationships like 'items' directly via setattr with a list of dicts
        if key not in ['items']: # Add other relationship fields if necessary
            if hasattr(db_proforma_invoice, key):
                setattr(db_proforma_invoice, key, value)
            # else: consider logging a warning for keys in update_data not in model

    try:
        db.commit()
        db.refresh(db_proforma_invoice)
        return db_proforma_invoice
    except Exception as e:
        db.rollback()
        raise e

def delete_proforma_invoice(db: Session, proforma_invoice_id: str) -> bool:
    """Deletes a Proforma Invoice and its associated items (due to cascade)."""
    # Fetch without items if cascade delete is correctly configured and items don't need pre-processing
    db_proforma_invoice = db.query(ProformaInvoice).filter(ProformaInvoice.id == proforma_invoice_id).first()
    if not db_proforma_invoice:
        return False

    db.delete(db_proforma_invoice)
    try:
        db.commit()
        return True
    except Exception as e:
        db.rollback()
        raise e

# --- ProformaInvoiceItem CRUD (Simplified - often managed via ProformaInvoice) ---

def create_proforma_invoice_item(db: Session, item_data: Dict[str, Any]) -> ProformaInvoiceItem:
    """
    Creates a single Proforma Invoice Item.
    Usually items are created with the Proforma Invoice itself.
    'item_data' must include 'proforma_invoice_id'.
    """
    if 'proforma_invoice_id' not in item_data:
        raise ValueError("proforma_invoice_id is required to create an item.")

    db_item = ProformaInvoiceItem(**item_data)
    db.add(db_item)
    try:
        db.commit()
        db.refresh(db_item)
        return db_item
    except Exception as e:
        db.rollback()
        raise e

def get_proforma_invoice_item_by_id(db: Session, item_id: str) -> Optional[ProformaInvoiceItem]:
    """Fetches a Proforma Invoice Item by its ID, including related product if needed."""
    return db.query(ProformaInvoiceItem).options(
        selectinload(ProformaInvoiceItem.product) # Load product if needed
    ).filter(ProformaInvoiceItem.id == item_id).first()

def update_proforma_invoice_item(db: Session, item_id: str, update_data: Dict[str, Any]) -> Optional[ProformaInvoiceItem]:

    db_item = get_proforma_invoice_item_by_id(db, item_id)
    if not db_item:
        return None

    for key, value in update_data.items():
        if hasattr(db_item, key):
            setattr(db_item, key, value)

    try:
        db.commit()
        db.refresh(db_item)
        return db_item
    except Exception as e:
        db.rollback()
        raise e

def delete_proforma_invoice_item(db: Session, item_id: str) -> bool:
    """Deletes a Proforma Invoice Item by its ID."""
    db_item = get_proforma_invoice_item_by_id(db, item_id)
    if not db_item:
        return False

    db.delete(db_item)
    try:
        db.commit()
        return True
    except Exception as e:
        db.rollback()
        raise e

# Example of how to get a session (replace with your actual session management)
def _get_example_session():
    from sqlalchemy import create_engine
    from sqlalchemy.orm import sessionmaker
    # Replace with your actual database URL
    # For this example, using an in-memory SQLite database
    SQLALCHEMY_DATABASE_URL = "sqlite:///:memory:" # In-memory for example
    engine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False})

    # This is crucial for the example to run: create tables based on models in api.models
    try:
        from api.models import Base as ApiModelsBase
        ApiModelsBase.metadata.create_all(bind=engine)
    except ImportError:
        print("CRITICAL FOR EXAMPLE: Could not import Base from api.models. Tables will not be created.")
    except Exception as e:
        print(f"CRITICAL FOR EXAMPLE: Error creating tables: {e}")

    SessionLocalExample = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    return SessionLocalExample()

if __name__ == "__main__":
    # Example Usage (requires api.models to be importable and correctly define SQLAlchemy Base and models)
    print("Running example CRUD operations for Proforma Invoices...")

    example_db_session = None # Initialize to None
    try:
        example_db_session = _get_example_session()

        # Need to create some dummy related data for FK constraints if not using mocks
        # This part is complex for a simple __main__ and depends on other CRUDs or direct model insertion

        # Simplified: Assume Client, Company, Product might exist or allow nulls, or insert simplified versions
        # For robust testing, these would be actual records or mocks.
        # For this example, we'll assume client_id, company_id, product_id are strings that don't need FK validation
        # in a simple test setup, or that the actual ProformaInvoice model allows them to be nullable for testing.
        # The provided models have them as non-nullable, so this example would ideally create them.

        print("Note: Example run assumes FK constraints can be met (e.g., dummy Client/Company/Product records exist or are not strictly enforced in this test environment).")

        sample_proforma_data = {
            "proforma_invoice_number": f"PI-MAIN-{uuid.uuid4().hex[:4].upper()}",
            "client_id": "client_main_test_id_1",
            "company_id": "company_main_test_id_1",
            "currency": "EUR",
            "subtotal_amount": 200.0,
            "vat_amount": 40.0,
            "grand_total_amount": 240.0,
            "status": "draft"
        }
        sample_items_data = [
            {"product_id": "prod_main_test_id_1", "description": "Example Product Alpha", "quantity": 2, "unit_price": 50.0, "total_price": 100.0},
            {"description": "Example Service Beta", "quantity": 1, "unit_price": 100.0, "total_price": 100.0}
        ]

        created_proforma = create_proforma_invoice(example_db_session, sample_proforma_data, sample_items_data)
        print(f"Created Proforma Invoice ID: {created_proforma.id}, Number: {created_proforma.proforma_invoice_number}, Status: {created_proforma.status.value if created_proforma.status else 'None'}")
        for item in created_proforma.items:
            print(f"  Item ID: {item.id}, Desc: {item.description}, Qty: {item.quantity}, Total: {item.total_price}")

        fetched_proforma = get_proforma_invoice_by_id(example_db_session, created_proforma.id)
        if fetched_proforma:
            print(f"Fetched Proforma by ID: {fetched_proforma.id}, Total: {fetched_proforma.grand_total_amount}, Items: {len(fetched_proforma.items)}")

        all_proformas = list_proforma_invoices(example_db_session, status_str="draft", limit=5)
        print(f"Listed Proformas (draft): {len(all_proformas)}")
        for pi_item in all_proformas:
            print(f"  - PI Num: {pi_item.proforma_invoice_number} (Status: {pi_item.status.value if pi_item.status else 'None'})")

        update_payload = {"status": "SENT", "notes": "Proforma has been sent to client via __main__ example."}
        updated_proforma = update_proforma_invoice(example_db_session, created_proforma.id, update_payload)
        if updated_proforma:
            print(f"Updated Proforma ID: {updated_proforma.id}, New Status: {updated_proforma.status.value if updated_proforma.status else 'None'}, Notes: {updated_proforma.notes}")

        # Example of updating an item (first item of the created proforma)
        if updated_proforma and updated_proforma.items:
            item_to_update_id = updated_proforma.items[0].id
            item_update_payload = {"quantity": 3, "total_price": 75.0} # Assuming unit_price is 25.0
            updated_item = update_proforma_invoice_item(example_db_session, item_to_update_id, item_update_payload)
            if updated_item:
                 print(f"Updated Item ID: {updated_item.id}, New Qty: {updated_item.quantity}, New Total: {updated_item.total_price}")


        # # Deleting item example (optional)
        # if updated_proforma and updated_proforma.items and len(updated_proforma.items) > 1:
        #     item_to_delete_id = updated_proforma.items[1].id
        #     deleted_item_res = delete_proforma_invoice_item(example_db_session, item_to_delete_id)
        #     print(f"Proforma Invoice Item {item_to_delete_id} deleted: {deleted_item_res}")
        #     fetched_proforma_after_item_delete = get_proforma_invoice_by_id(example_db_session, created_proforma.id)
        #     if fetched_proforma_after_item_delete:
        #         print(f"Proforma {fetched_proforma_after_item_delete.id} now has {len(fetched_proforma_after_item_delete.items)} items.")


        # # Deleting proforma example (optional)
        # deleted_proforma_res = delete_proforma_invoice(example_db_session, created_proforma.id)
        # print(f"Proforma Invoice {created_proforma.id} deleted: {deleted_proforma_res}")
        # verify_deleted_proforma = get_proforma_invoice_by_id(example_db_session, created_proforma.id)
        # print(f"Verification: Fetched Proforma after delete: {verify_deleted_proforma}")


    except NotImplementedError as nie:
        print(f"Skipping example run due to placeholder function not implemented: {nie}")
    except Exception as e:
        print(f"Error during example run: {e}")
        import traceback
        traceback.print_exc()
    finally:
        if example_db_session:
            example_db_session.close()
            print("Example DB session closed.")

    print("Example CRUD operations finished.")
    pass
