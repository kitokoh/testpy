import os
import sys # For sys.path modification
from PyQt5.QtWidgets import QMessageBox
from PyQt5.QtGui import QDesktopServices
from PyQt5.QtCore import QUrl

# Adjust sys.path to include the parent directory for db and utils
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
import db as db_manager
import html_to_pdf_util
from app_config import CONFIG
from PyQt5.QtGui import QDesktopServices # Added
from PyQt5.QtCore import QUrl # Added

try:
    from email_service import EmailSenderService
except ImportError:
    if os.path.abspath(os.path.join(os.path.dirname(__file__), '..')) not in sys.path:
        sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
    from email_service import EmailSenderService


class LiteDocumentHandler:
    def __init__(self, parent_modal=None):
        self.parent_modal = parent_modal

    def _get_client_and_company_ids(self) -> tuple[str | None, str | None]:
        default_company = db_manager.get_default_company()
        company_id = default_company['company_id'] if default_company else None

        all_clients = db_manager.get_all_clients()
        # Ensure all_clients is not empty and its elements are dictionaries
        client_id = None
        if all_clients and isinstance(all_clients[0], dict) and 'client_id' in all_clients[0]:
            client_id = all_clients[0]['client_id']

        if not company_id:
            print("Warning: No default company found.")
            # Optionally show message box if parent_modal is available
            # if self.parent_modal:
            #     QMessageBox.warning(self.parent_modal, "Setup Warning", "No default company found. Please configure one.")

        if not client_id:
            print("Warning: No clients found in DB or client data is invalid. PDF context will be incomplete.")
            # Optionally show message box
            # if self.parent_modal:
            #     QMessageBox.warning(self.parent_modal, "Data Warning", "No clients found. PDF context will be incomplete.")

        return client_id, company_id

    def _prepare_document_context(self, selected_language_code: str, selected_country_data: dict, selected_products_with_qty: list, additional_doc_context: dict = None) -> dict | None:
        client_id_override = (additional_doc_context or {}).pop('client_id_override', None) # pop to remove it
        temp_client_id, company_id = self._get_client_and_company_ids()
        final_client_id = client_id_override if client_id_override else temp_client_id

        if not final_client_id or not company_id:
            error_message = "Company ID or a Client ID is missing. Cannot prepare document context."
            if self.parent_modal:
                QMessageBox.critical(self.parent_modal, "Error", error_message)
            else:
                print(f"Error: {error_message}")
            return None

        additional_context_for_db = {'lite_selected_products': selected_products_with_qty}
        if additional_doc_context: # additional_doc_context has had client_id_override popped
            additional_context_for_db.update(additional_doc_context)

        context = db_manager.get_document_context_data(
            client_id=final_client_id, # Use final_client_id
            company_id=company_id,
            target_language_code=selected_language_code,
            project_id=None,
            linked_product_ids_for_doc=[],
            additional_context=additional_context_for_db
        )

        if context and selected_country_data:
            context['doc_specific_country_selection'] = selected_country_data

        return context

    # Placeholder methods for main actions
    def generate_and_visualize_pdfs(self, language_code: str, country_data: dict, products_with_qty: list, templates_data: list[dict], pdf_action: str):
        print("generate_and_visualize_pdfs called with:")
        print(f"  Language: {language_code}, Country: {country_data.get('country_name') if country_data else 'N/A'}, PDF Action: {pdf_action}")
        # print(f"  Products: {products_with_qty}") # Can be verbose
        # print(f"  Templates: {[t.get('template_name') for t in templates_data]}") # Can be verbose

        doc_context = self._prepare_document_context(language_code, country_data, products_with_qty)
        if not doc_context:
            # Error message already shown by _prepare_document_context or its sub-calls
            print("Document context preparation failed. Aborting PDF generation.")
            return # Can't proceed without context

        pdf_outputs = self._generate_pdf_outputs(doc_context, templates_data, pdf_action)

        if not pdf_outputs:
            # Warning already shown by _generate_pdf_outputs if it returned None
            print("No PDF outputs were generated by _generate_pdf_outputs.")
            return

        # At this point, pdf_outputs is a list of (name, pdf_bytes) tuples
        print(f"Successfully generated {len(pdf_outputs)} PDF document(s).")

        # For visualization, save to temp files and open
        temp_dir = CONFIG.get("document_generation_temp_dir", "temp_generated_docs")
        if not os.path.exists(temp_dir):
            os.makedirs(temp_dir, exist_ok=True)

        opened_files_count = 0
        for i, (name, pdf_bytes) in enumerate(pdf_outputs):
            # Sanitize name for use as a filename
            safe_name = "".join(c if c.isalnum() else "_" for c in name)
            # Ensure unique filename if multiple PDFs might have similar names (e.g. from same template name but different context)
            temp_pdf_path = os.path.join(temp_dir, f"{safe_name}_{i+1}.pdf")

            try:
                with open(temp_pdf_path, 'wb') as f:
                    f.write(pdf_bytes)
                print(f"Saved PDF to: {temp_pdf_path}")

                # Open the PDF using the default system viewer
                if not QDesktopServices.openUrl(QUrl.fromLocalFile(os.path.abspath(temp_pdf_path))):
                    if self.parent_modal:
                        QMessageBox.warning(self.parent_modal, "Opening PDF Failed", f"Could not open {temp_pdf_path}.\nPlease check if you have a default PDF viewer configured.")
                    else:
                        print(f"Warning: Could not open {temp_pdf_path}. Please check default PDF viewer.")
                else:
                    opened_files_count +=1
            except Exception as e_save:
                print(f"Error saving or opening PDF {temp_pdf_path}: {e_save}")
                if self.parent_modal:
                    QMessageBox.critical(self.parent_modal, "File Error", f"Could not save or open PDF: {temp_pdf_path}\n{e_save}")

        if opened_files_count > 0 and self.parent_modal:
            QMessageBox.information(self.parent_modal, "PDFs Generated",
                                    f"{opened_files_count} PDF(s) generated and saved to '{temp_dir}'.\nAttempted to open them with system viewer.")
        elif opened_files_count == 0 and self.parent_modal:
             QMessageBox.warning(self.parent_modal, "PDFs Not Opened",
                                 f"PDFs were generated but could not be saved or opened. Check console/logs.")


    def _generate_single_pdf_bytes(self, html_content: str, template_directory: str) -> bytes | None:
        """Helper to convert a single HTML string to PDF bytes."""
        try:
            # Ensure template_directory is an absolute path for base_url
            abs_template_directory = os.path.abspath(template_directory)
            base_url = f"file://{abs_template_directory}{os.sep}"
            pdf_bytes = html_to_pdf_util.convert_html_to_pdf(html_content, base_url=base_url)
            return pdf_bytes
        except Exception as e:
            print(f"Error generating single PDF: {e}")
            # Optionally, show message to user if parent_modal is available
            # if self.parent_modal:
            #     QMessageBox.critical(self.parent_modal, "PDF Conversion Error", f"Failed to convert HTML to PDF: {e}")
            return None

    def _generate_pdf_outputs(self, context_data: dict, templates_data: list[dict], pdf_action: str) -> list[tuple[str, bytes]] | None:
        generated_pdfs = []
        rendered_html_parts = []
        # Use a default if CONFIG or templates_dir is not found, or handle error more gracefully
        template_base_dir_config = CONFIG.get("templates_dir", "templates")
        # Ensure template_base_dir is an absolute path from the application root
        # Assuming CONFIG refers to app_config.py in the root, and templates_dir is relative to that.
        # If CONFIG['application_path'] is available:
        app_root = CONFIG.get("application_path", os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
        template_base_dir = os.path.join(app_root, template_base_dir_config)


        for template_info in templates_data:
            template_name = template_info.get('template_name', 'Untitled Document')
            template_html_content = None

            if template_info.get('raw_template_file_data'):
                raw_data = template_info['raw_template_file_data']
                if isinstance(raw_data, bytes):
                    try:
                        template_html_content = raw_data.decode('utf-8')
                    except UnicodeDecodeError:
                        print(f"Error decoding raw template data for {template_name}. Assuming it's not text.")
                        # Potentially handle non-text raw data if applicable, or skip
                        continue
                elif isinstance(raw_data, str):
                    template_html_content = raw_data
                else:
                    print(f"Warning: Raw template data for {template_name} is of unexpected type: {type(raw_data)}")
                    continue

            elif template_info.get('base_file_name') and template_info.get('language_code'):
                # Construct path relative to the main templates directory
                file_path = os.path.join(template_base_dir, template_info['language_code'], template_info['base_file_name'])
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        template_html_content = f.read()
                except FileNotFoundError:
                    print(f"Error: Template file not found at {file_path} for template: {template_name}")
                    continue
                except Exception as e:
                    print(f"Error reading template file {file_path}: {e}")
                    continue

            if not template_html_content:
                print(f"Could not load content for template: {template_name}")
                continue

            try:
                rendered_html = html_to_pdf_util.render_html_template(template_html_content, context_data)
            except Exception as e_render: # Catch errors during Jinja2 rendering
                print(f"Error rendering HTML for template {template_name}: {e_render}")
                if self.parent_modal:
                    QMessageBox.warning(self.parent_modal, "Template Error", f"Error rendering template '{template_name}':\n{e_render}")
                continue # Skip this template

            if pdf_action == "separate":
                # For separate PDFs, the base_url for resource loading should point to the specific template's directory
                # or a common resource directory. Here, template_base_dir is common.
                pdf_bytes = self._generate_single_pdf_bytes(rendered_html, template_base_dir)
                if pdf_bytes:
                    generated_pdfs.append((template_name, pdf_bytes))
            elif pdf_action == "combine":
                rendered_html_parts.append(rendered_html)
            else: # Should not happen with radio buttons
                print(f"Unknown PDF action: {pdf_action}")


        if pdf_action == "combine" and rendered_html_parts:
            page_break_html = '<div style="page-break-after:always;"></div>'
            # Avoid adding page break after the last part
            combined_html = ""
            for i, part_html in enumerate(rendered_html_parts):
                combined_html += part_html
                if i < len(rendered_html_parts) - 1: # Not the last part
                    combined_html += page_break_html

            pdf_bytes = self._generate_single_pdf_bytes(combined_html, template_base_dir)
            if pdf_bytes:
                generated_pdfs.append(("Combined Document", pdf_bytes))

        if not generated_pdfs:
            if self.parent_modal:
                QMessageBox.warning(self.parent_modal, "PDF Generation Failed", "No PDF documents could be generated. Check logs for errors.")
            else:
                print("Warning: No PDF documents were generated.")
            return None

        return generated_pdfs


    def generate_and_send_email(self, client_id_for_context: str, language_code: str, country_data: dict, products_with_qty: list, templates_data: list[dict], pdf_action: str, recipients: list[str], subject: str, body_html: str) -> bool:
        print(f"generate_and_send_email called for client: {client_id_for_context}")

        doc_context = self._prepare_document_context(
            selected_language_code=language_code,
            selected_country_data=country_data,
            selected_products_with_qty=products_with_qty,
            additional_doc_context={'client_id_override': client_id_for_context}
        )

        if not doc_context:
            if self.parent_modal:
                QMessageBox.critical(self.parent_modal, "Email Error", "Failed to prepare document context for email.")
            else:
                print("Email Error: Failed to prepare document context.")
            return False

        generated_pdf_data_list = self._generate_pdf_outputs(doc_context, templates_data, pdf_action)

        if not generated_pdf_data_list:
            # Error message already shown by _generate_pdf_outputs
            return False

        temp_dir = CONFIG.get("document_generation_temp_dir", "temp_docs")
        os.makedirs(temp_dir, exist_ok=True)
        attachment_paths = []

        try:
            for pdf_name, pdf_bytes in generated_pdf_data_list:
                safe_filename = "".join([c if c.isalnum() else "_" for c in pdf_name]) + ".pdf"
                temp_pdf_path = os.path.join(temp_dir, safe_filename)
                with open(temp_pdf_path, 'wb') as f:
                    f.write(pdf_bytes)
                attachment_paths.append(temp_pdf_path)
                print(f"Prepared attachment: {temp_pdf_path}")

            email_service = EmailSenderService() # Assumes default SMTP config or one is set via settings

            if not email_service.smtp_config:
                if self.parent_modal:
                    QMessageBox.critical(self.parent_modal, "Email Error", "SMTP configuration not found or invalid. Cannot send email.")
                else:
                    print("Email Error: SMTP configuration not found or invalid.")
                return False # Must return False after cleanup

            success, message = email_service.send_email(
                client_id=client_id_for_context, # For logging/tracking purposes in email_service
                recipients=recipients,
                subject_template=subject, # Passed as already rendered/final string
                body_html_template=body_html, # Passed as already rendered/final string
                attachments=attachment_paths,
                template_language_code=language_code, # For potential use in email_service if it does further templating
                project_id=doc_context.get('project', {}).get('id') # For logging/tracking
            )

            if success:
                if self.parent_modal:
                    QMessageBox.information(self.parent_modal, "Email Sent", f"Email successfully sent. Message: {message}")
                print(f"Email successfully sent. Message: {message}")
                return True
            else:
                if self.parent_modal:
                    QMessageBox.warning(self.parent_modal, "Email Failed", f"Failed to send email. Error: {message}")
                print(f"Failed to send email. Error: {message}")
                return False

        except Exception as e:
            print(f"An error occurred during email preparation or sending: {e}")
            if self.parent_modal:
                QMessageBox.critical(self.parent_modal, "Email System Error", f"An unexpected error occurred: {e}")
            return False
        finally:
            # Cleanup temporary files
            for path in attachment_paths:
                try:
                    if os.path.exists(path):
                        os.remove(path)
                        print(f"Cleaned up attachment: {path}")
                except Exception as e_cleanup:
                    print(f"Error cleaning up attachment {path}: {e_cleanup}")


if __name__ == '__main__':
    print("LiteDocumentHandler - basic test execution if run directly")

    db_manager.initialize_database()
    handler = LiteDocumentHandler()

    print("Testing _get_client_and_company_ids...")
    client_id, company_id = handler._get_client_and_company_ids()
    print(f"  Client ID: {client_id}, Company ID: {company_id}")

    if client_id and company_id:
        print("\nTesting _prepare_document_context...")
        dummy_lang = 'en'
        dummy_country = {'country_id': 1, 'country_name': 'Testland'}

        dummy_products = []
        all_prods = db_manager.get_all_products() # This returns a list of Product namedtuples
        if all_prods:
            # Convert namedtuple to dict for consistency with what LitePDFModal would pass
            first_prod = all_prods[0]
            dummy_products = [{'product_id': first_prod.product_id,
                               'quantity': 2,
                               'name': first_prod.product_name}]
        else:
            print("  Skipping _prepare_document_context test: No products in DB to test with.")

        if dummy_products:
            context = handler._prepare_document_context(dummy_lang, dummy_country, dummy_products)
            if context:
                print("  Successfully prepared document context (first few keys):")
                for i, (k, v) in enumerate(context.items()):
                    if i < 5:
                        print(f"    {k}: {'[complex value]' if isinstance(v, (dict, list)) else v}")
                    else:
                        break
            else:
                print("  Failed to prepare document context.")
    else:
        print("\nSkipping _prepare_document_context test due to missing client/company ID.")

    print("\nTesting placeholder actions...")
    # Need valid data for these calls, even if placeholders
    valid_lang = 'en'
    valid_country = {'country_id': 1, 'name': 'Testland'}
    valid_products = []
    if all_prods: # Reuse fetched products
         first_prod = all_prods[0]
         valid_products = [{'product_id': first_prod.product_id, 'quantity': 1, 'name': first_prod.product_name}]


    handler.generate_and_visualize_pdfs(valid_lang, valid_country, valid_products, [], "separate")
    handler.generate_and_send_email(valid_lang, valid_country, valid_products, [], "separate")

    print("\nLiteDocumentHandler basic test finished.")
