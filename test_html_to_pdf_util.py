import unittest
import os
from html_to_pdf_util import populate_html, convert_html_to_pdf, WeasyPrintError

# Determine APP_ROOT_DIR for potential file operations if needed later.
# For tests, usually, the current working directory or the directory of the test file is sufficient.
APP_ROOT_DIR = os.path.dirname(os.path.abspath(__file__))


class TestHtmlToPdfUtil(unittest.TestCase):

    def test_populate_html_basic_replacement(self):
        template_content = "<html><head><title>{{TITLE}}</title></head><body><h1>{{HEADING}}</h1><p>By {{AUTHOR}}.</p></html>"
        data = {
            "TITLE": "My Awesome Page",
            "HEADING": "Welcome!",
            "AUTHOR": "John Doe"
        }
        expected_output = "<html><head><title>My Awesome Page</title></head><body><h1>Welcome!</h1><p>By John Doe.</p></html>"
        self.assertEqual(populate_html(template_content, data), expected_output)

    def test_populate_html_missing_placeholders_in_data(self):
        template_content = "<html><body><p>{{CONTENT}}</p><p>Date: {{DATE}}</p></body></html>"
        data = {
            "CONTENT": "This is some content."
            # DATE is missing in data
        }
        # The current implementation of populate_html leaves placeholders as is if not in data.
        expected_output = "<html><body><p>This is some content.</p><p>Date: {{DATE}}</p></body></html>"
        self.assertEqual(populate_html(template_content, data), expected_output)

    def test_populate_html_extra_keys_in_data(self):
        template_content = "<html><title>{{TITLE}}</title></html>"
        data = {
            "TITLE": "Test Title",
            "UNUSED_KEY": "This should not cause issues."
        }
        expected_output = "<html><title>Test Title</title></html>"
        self.assertEqual(populate_html(template_content, data), expected_output)

    def test_populate_html_empty_data(self):
        template_content = "<html><title>{{TITLE}}</title><body>{{BODY}}</body></html>"
        data = {}
        # Placeholders should remain if data is empty
        expected_output = "<html><title>{{TITLE}}</title><body>{{BODY}}</body></html>"
        self.assertEqual(populate_html(template_content, data), expected_output)

    def test_populate_html_empty_template(self):
        template_content = ""
        data = {"TITLE": "Test"}
        expected_output = ""
        self.assertEqual(populate_html(template_content, data), expected_output)

    def test_populate_html_placeholders_with_different_casing_in_data(self):
        # Current implementation is case-sensitive for keys in `data` matching `{{PLACEHOLDER}}`
        template_content = "<html><body><p>{{Name}}</p></body></html>"
        data = {"name": "lowercase_key_value"}
        # This will not replace because "Name" in template vs "name" in data.
        expected_output = "<html><body><p>{{Name}}</p></body></html>"
        self.assertEqual(populate_html(template_content, data), expected_output)

        data_correct_case = {"Name": "CorrectCaseValue"}
        expected_output_correct_case = "<html><body><p>CorrectCaseValue</p></body></html>"
        self.assertEqual(populate_html(template_content, data_correct_case), expected_output_correct_case)

    # --- Tests for convert_html_to_pdf ---

    def test_basic_pdf_conversion(self):
        simple_html = "<html><body><h1>Test PDF Conversion</h1><p>Hello, World!</p></body></html>"
        pdf_bytes = convert_html_to_pdf(simple_html)
        self.assertIsNotNone(pdf_bytes)
        self.assertIsInstance(pdf_bytes, bytes)
        self.assertTrue(pdf_bytes.startswith(b'%PDF-'), "Generated bytes do not look like a PDF.")

    def test_pdf_conversion_empty_html(self):
        # WeasyPrint can actually convert an empty string to a (very small) valid PDF.
        empty_html = ""
        pdf_bytes = convert_html_to_pdf(empty_html)
        self.assertIsNotNone(pdf_bytes)
        self.assertIsInstance(pdf_bytes, bytes)
        self.assertTrue(pdf_bytes.startswith(b'%PDF-'))

    @unittest.expectedFailure
    def test_pdf_conversion_error_conditions(self):
        # This test is marked as an expected failure.
        # WeasyPrint's write_pdf() seems resilient to invalid base_urls or missing relative resources
        # when the HTML itself is simple and doesn't strictly depend on immediate failure for these.
        # It might log warnings or produce a PDF without the problematic element, rather than raising
        # an exception that convert_html_to_pdf's try-except for URLFetchingError or general Exception
        # would catch from the write_pdf() call itself for these specific inputs.
        # The error handling in convert_html_to_pdf is still valuable for other types of errors
        # that *would* be raised by WeasyPrint during write_pdf().

        # Test with HTML that has a relative image path, and an invalid base_url.
        html_with_relative_image = "<html><body><img src='relative_image.png'></body></html>"
        invalid_base_url = "this_is_not_a_valid_url_or_path" # Syntactically invalid base_url

        with self.assertRaises(WeasyPrintError):
            convert_html_to_pdf(html_with_relative_image, base_url=invalid_base_url)

    def test_pdf_conversion_with_syntax_error_html(self):
        # WeasyPrint is often very tolerant of minor HTML syntax errors.
        # True "invalid" HTML that causes a parsing crash in WeasyPrint itself is rare.
        # This test is more about very broken structures, though WeasyPrint might still try its best.
        # If WeasyPrint fails to parse, it might raise an internal error before write_pdf is even called.
        # The current `convert_html_to_pdf` catches general Exception.
        html_with_syntax_error = "<html><body><h1>Unclosed Tag<p>Another tag</body></html>"
        try:
            pdf_bytes = convert_html_to_pdf(html_with_syntax_error)
            # Depending on WeasyPrint's leniency, it might still produce a PDF.
            if pdf_bytes is not None:
                self.assertIsInstance(pdf_bytes, bytes)
                self.assertTrue(pdf_bytes.startswith(b'%PDF-'))
            # else:
                # This case would be if convert_html_to_pdf returned None without an exception,
                # which is not its current design for write_pdf errors.
                # self.assertIsNone(pdf_bytes, "Expected None for severely broken HTML if not raising exception.")
        except WeasyPrintError as e:
            # This is an acceptable outcome if WeasyPrint (or our wrapper) deems the HTML unprocessable.
            self.assertIsNotNone(e, "WeasyPrintError should be raised for problematic HTML.")


    # Note on testing base_url with local files:
    # To test base_url for local image loading, one would typically:
    # 1. Create a temporary directory.
    # 2. Place a dummy image file (e.g., a small valid PNG) in that directory.
    # 3. Construct HTML that references this image using a relative path (e.g., <img src="dummy.png">).
    # 4. Call convert_html_to_pdf with this HTML and base_url set to the 'file://' URI of the temporary directory.
    # 5. Assert that the PDF is generated (doesn't raise URLFetchingError).
    # 6. (Optional, more advanced) Inspect the PDF content to heuristically check if an image was embedded.
    # This setup is beyond a quick implementation here but is a good candidate for more comprehensive tests.

if __name__ == '__main__':
    # Before running tests, ensure WeasyPrint and its dependencies are installed.
    # The environment might need libraries like Pango, Cairo, GDK-PixBuf.
    # If running in a CI/CD environment, these dependencies must be available.
    print("Running HTML to PDF Util tests...")
    print("Ensure WeasyPrint and its system dependencies (Pango, Cairo, etc.) are installed.")
    unittest.main()
